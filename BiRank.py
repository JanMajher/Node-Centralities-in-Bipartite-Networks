# -*- coding: utf-8 -*-
"""BiRank.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ay1mkSmtOEsFB08qQA908aLUS9Z_3ju2
"""

import networkx as nx
import pandas as pd
import numpy as np
import scipy
import scipy.sparse as spa
from networkx.algorithms import bipartite
from networkx.algorithms.bipartite import biadjacency_matrix

def birank(W, u0=None, v0=None,
    alpha=0.85, beta=0.85, max_iter=200, tol=1.0e-4, verbose=False):
    """
    Calculate the PageRank of bipartite networks directly.
    See paper https://ieeexplore.ieee.org/abstract/document/7572089/
    for details.
    Different normalizer yields very different results.
    More studies are needed for deciding the right one.
    Input:
        W::scipy's sparse matrix:Adjacency matrix of the bipartite network D*P
        alpha, beta::float:Damping factors for the rows and columns
        max_iter::int:Maximum iteration times
        tol::float:Error tolerance to check convergence
        verbose::boolean:If print iteration information
    Output:
         d, p::numpy.ndarray:The BiRank for rows and columns
    """
    # default initial vectors: 1/|U|, 1/|V|
    if u0 is None:
        u0=np.repeat(1 / W.shape[0], W.shape[0])
    if v0 is None:
        v0=np.repeat(1 / W.shape[1], W.shape[1])


    W = W.astype('float', copy=False)
    WT = W.T

    Ku = np.array(W.sum(axis=1)).flatten()
    Kv = np.array(W.sum(axis=0)).flatten()
    # avoid divided by zero issue
    Ku[np.where(Ku==0)] += 1
    Kv[np.where(Kv==0)] += 1

    Ku_ = spa.diags(1/Ku)
    Kv_ = spa.diags(1/Kv)

    Ku_bi = spa.diags(1/np.sqrt(Ku))
    Kv_bi = spa.diags(1/np.sqrt(Kv))
    Sv = Kv_bi.dot(WT).dot(Ku_bi)
    Su = Sv.T


    u_last = u0.copy()
    v_last = v0.copy()

    for i in range(max_iter):
        u = alpha * (Su.dot(v_last)) + (1-alpha) * u0
        v = beta * (Sv.dot(u_last)) + (1-beta) * v0

        err_u = np.absolute(u - u_last).sum()
        err_v = np.absolute(v - v_last).sum()
        
        if verbose:
            print(
                "Iteration : {}; top error: {}; bottom error: {}".format(
                    i, err_u, err_v
                )
            )
        if err_v < tol and err_u < tol:
            break
        u_last = u
        v_last = v

    return u, v

def gen_W(users, items, ratings):
    """
    This function generates sparse matrix represantation of bipartite graph
    for players and linups
    Input:
      users - pandas series
      items - pandas series
      ratings - pandas series
    Output:
      sparse biadjacency matrix W 
    """

    # initiate graph
    user = users.tolist()
    item = items.tolist()
    rating = ratings.tolist()
    B = nx.Graph()
    B.add_nodes_from(user, bipartite=0)
    B.add_nodes_from(item, bipartite=1)

    # create edges
    for i in range(len(user)):
        B.add_edges_from([(user[i], item[i])])
        B[user[i]][item[i]]['weight'] = rating[i]

    users_unique = users.unique()   
    items_unique = items.unique()

    # BiAdjacency matrix - for bipartite network
    W = biadjacency_matrix(B, users_unique,items_unique).toarray()

    # sparce form of Biadjacency matrix
    W = spa.csr_matrix(W)
    print('Shape of W: '+str(W.shape))

    return W, users_unique, items_unique